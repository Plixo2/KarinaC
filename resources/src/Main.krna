

fn main() {


    let list = ListOf()
    list.add(1)
    list.add(2)
    list.add(3)
    list.add(4)
    list.add(5)
    list.add(6)
    list.add(7)
    list.add(8)
    list.add(9)

    let newList = list.map(fn(v) v).filter(fn(v) v > 5);
    newList.forEach(fn(v) println(v))

    println(newList.contains(fn(v) v == 6))
    println(newList.indexOf(fn(v) v == 4))
    println(newList.indexOf(fn(v) v == 8))

    let inte = {
        0 + 1 * 10
    } 

    println(1 * 2 + 3)


    0
}



fn cast<I, R>(i: I) -> R = i


struct List<T> {
    storage: [T]
    capacity: int
    size: int
    
    fn size() -> int {
        return 0
    }

    fn get(i: int) -> T {
        if i >= self.size || i < 0 {
           raise Error { message: "Index out of bounds" }
        }

        return self.storage[i]
    }

    fn set(i: int, v: T) {
        if i >= self.size || i < 0 {
            raise Error { message: "Index out of bounds" }
        }
        self.storage[i] = v
    }

    fn add(v: T) {
        if self.size == self.capacity {
            self.capacity = max(self.capacity, 1) * 2
            let newArray = array<T>(self.capacity)
            let index = 0

            while index < self.size {
                newArray[index] = self.storage[index]
                index = index + 1
            }

            self.storage = newArray
        }
        self.storage[self.size] = v
        self.size = self.size + 1
    }

    fn map<U>(f: fn(T) -> U) -> List<U> {
        let index = 0
        let newList = List { storage: array(self.size), capacity: self.size, size: self.size }

        while index < self.size { 
            newList.set(index, f(self.storage[index]))
            index = index + 1
        }
        return newList
    }

    fn filter(f: fn(T) -> bool) -> List<T> {
        let index = 0
        let newList = List { storage: array(self.size), capacity: self.size, size: 0 }

        while index < self.size {
            if f(self.storage[index]) {
                newList.add(self.storage[index])
            }
            index = index + 1
        }

        return newList


    }

    fn forEach(f: fn(T)) {
        let index = 0
        while index < self.size {
            f(self.storage[index])
            index = index + 1
        }
    }

    fn contains(f: fn(T) -> bool) -> bool {
        let index = 0
        while index < self.size {
            if f(self.storage[index]) {
                return true
            }
            index = index + 1
        }
        return false
    }

    fn indexOf(f: fn(T) -> bool) -> int {
        let index = 0
        while index < self.size {
            if f(self.storage[index]) {
                return index
            }
            index = index + 1
        }
        return -1
    }

    fn iterator() -> Iterator<T> {
        let index = [0]

        let next = fn() {
            let value = self.storage[index[0]]
            index[0] = index[0] + 1
            return value
        }

        let hasNext = fn () index[0] < self.size

        return Iterator { next: next, hasNext: hasNext }
    }

}

@Throwable
struct Error { 
    message: string
}


struct Iterator<T> {
    next: fn() -> T
    hasNext: fn() -> bool
}

fn max(a: int, b: int) -> int = if a > b { a } else { b }
fn min(a: int, b: int) -> int = if a < b { a } else { b }

fn ListOf<T>() -> List<T> {
    return List { storage: array(4), capacity: 4, size: 0 }
}

@Native
@Unsafe
fn array<T>(size: int) -> [T] = []

@Native
fn println<T>(v: T) {}

fn getNonSpecial<T>(a: [T]) -> NonSpecial<T> = NonSpecial{ a: a[0] }

struct NonSpecial<T> {
    a: T
}

fn boolToString(b: bool) -> string = if b { "true" } else { "false" }

fn callMe<T>(i: Help<T>) -> Help<T> {
    return i
}

struct Help<T> {
    a: int
    b: T
    state: bool

    fn add<W>(a: T, b: W) -> Tuple<T, W> {
       return Tuple { a: a, b: b }
    }
}

struct Tuple<T, U> {
    a: T
    b: U

    fn first() -> T = self.a
    fn second() -> U = self.b
}