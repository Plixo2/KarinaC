//import java::java.lang.System
import test binary
import java::java.lang.Object

fn main(args: [string]) {
    printBool(test())
    println(arrayToString(args))
    let len = args.size;
    println("Args: ")
    println(Int.new(len))

    let index: float = 0.0;
    while (index < (args.size as float)) {
        println(args[index as int])
        index = index + 1.0;
    }


    let carNormal = Car { color: "green", conf: 99 }

    let carDefault = Car.default()

    let base = getBase(carDefault)



    let car = Vehicle.carOf("blue")

    println(car.base())
    println(getBase(carNormal))

    let something = Option.Some(Int.new(1))
    let none = Option.None<Int>()

    let ok = Result.Ok<string, int>("Hello")

    println(ok)

    if false  {
        let str = "Hello"
        let res = try(fn() "str")
    }
}


fn try<T>(f: fn() -> T) -> Result<T, ?> {
    f()
    Result.Ok(f)
}

fn getBase<T>(v: Vehicle<T>) -> T {
    v.base()
}

enum Result<T, E> {
    Ok(value: T)
    Err(error: E)
}

struct IOError {
    message: string
}

fn readFile(str: string) -> Result<string, IOError> {
    Result.Ok("Hello")
}

@Native
fn println<T>(v: T) {}
@Native
fn intToString(i : int) -> string = ""
@Native
fn arrayToString<T>(a : [T]) -> string = ""


fn printBool(v: bool) {
    println(Bool.new(v))
}


struct Car {
    color: string
    conf: int

    fn getColor(self) -> string {
        self.color
    }

    fn getDefConf() -> int {
        let a = 10
        return 10
    }

    fn default() -> Car {
        Car { color: "red", conf: 1 }
    }

    impl Vehicle<Int> {
        fn base(self) -> ? {
            Int.new(self.conf)
        }
        fn setColor(self, color: string) {
            self.color = color
        }
    }
}

enum Option<T> {
    Some(value: T)
    None
}

struct Int {
    value: int

    fn new(value: int) -> Int {
        Int { value: value }
    }

    fn add(self, other: Int) -> Int {
        Int { value: self.value + other.value }
    }


    fn toString(self) -> string {
        intToString(self.value)
    }

}

struct Bool {
    value: bool

    fn new(value: bool) -> Bool {
        Bool { value: value }
    }

    fn toString(self) -> string {
        if self.value {
            "true"
        } else {
            "false"
        }
    }

}



//@Symbol = "+"
//@Extends = "Int"
//fn add(fst: Int, other: Int) -> Int {
   // Int { value: fst.value + other.value }
//}


interface Vehicle<T> {
    fn base(self) -> T
    fn setColor(self, color: string)


    fn carOf(color: string) -> Vehicle<Int> {
        Car { color: color, conf: 1 }
    }
}



