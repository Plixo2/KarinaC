


fn main() {

    let carNormal = Car { color: "green", conf: 99 }

    let carDefault = Car.default()
    //let b = carDefault.base()

    //let base = getBase(carDefault)


    let car = Vehicle.carOf("blue")

    println(car.base())
    println(carDefault.base())
    println(getBase(carNormal))

    let something = Option.Some(1)
    let none = Option.None<int>()


    let path = "resources/src/Main.krna"
    let file = readFile(path)
    if file is Ok ok {
        let val = ok.value;
        println(val)
    } else if file is Err err {
        println("err")
    }

    1
}

fn getBase<T>(v: Vehicle<T>) -> T {
    v.base()
}

enum Result<T, E> {
    Ok(value: T)
    Err(error: E)
}

struct IOError {
    message: string
}

fn readFile(str: string) -> Result<string, IOError> {
    Result.Ok("Hello")
}

@Native
fn println<T>(v: T) {}

struct Car {
    color: string
    conf: int

    fn default() -> Car {
        Car { color: "red", conf: 1 }
    }

    impl Vehicle<int> {
        fn base(self) -> int {
            self.conf
        }
        fn setColor(self, color: string) {
            self.color = color
        }
    }
}

enum Option<T> {
    Some(value: T)
    None
}




interface Vehicle<T> {
    fn base(self) -> T
    fn setColor(self, color: string)


    fn carOf(color: string) -> Vehicle<int> {
        Car { color: color, conf: 1 }
    }
}



