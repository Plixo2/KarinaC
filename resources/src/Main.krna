
import java.lang.String valueOf
import java.lang.Throwable
import karina.lang.Result { tryFunction }
import karina.lang.Result.Ok
import karina.lang.Result.Err
import src.Main.Inner
import java.util.function.Supplier
import java.lang.System out
import karina.lang.Option { some, none }
//import src.Main.Option { some, none }
import java.util.ArrayList


fn main() {
   // let a: int = 1
   // let b: string = "Hello World"
   // let c: String = String.valueOf(a)
   // let d: String = valueOf(c)
   // let f: String = String.valueOf(1)

    out.println("Hello World")
}

fn get() -> ? {
   // let i: java.lang.Integer = Integer.valueOf(1)

    //  let w = SimpleSupplier { value: 10 }
    //let b = a.
 //   let result: Result<Integer, java.lang.Throwable> = tryFunction(SimpleSupplier { value: 10})
 //   let result2 = tryFunction(fn() impl Supplier<?> Integer.valueOf(10))
 //   let result3 = tryFunction(fn() Integer.valueOf(10))
  //  if result is Result.Ok value {
  //      let w = value
  //  } else is Result.Err e {
  //      let error = e
 //   }
    //let o = getAsAny("Hello")
    //if o is Other(w) {

    //} else is Result.Ok(value) {

    //}

    //return 1;

    let list = ArrayList<Integer> {
        initialCapacity: 10
    }
    let _ = list.add(10)

    for a in list {
        let s: int = a

    }

   // let _b: int = list.get(10)
   // let ww = _b

    let a = "Hello"
    let interpolated = 'Hello if $a'

    let s  = ObjectSome {
        \fn: "Hello"
    }
    let str: string = s.\fn
    str
}

fn test() -> bool {


    let s: Option<Integer> = some(Integer.valueOf(10))

    let s2: TestInterface<Integer, String> = Test { inner: box(10) }

    let i: int = if s is Option.Some some {
        some.value.intValue()
    } else is Option.None {
        -1000
    }


    let unbox_int: int = Integer.valueOf(10)
    let unbox_long: long = Long.valueOf(10)
    let unbox_double: double = Double.valueOf(10)
    let unbox_float: float = Float.valueOf(10)
    let unbox_bool: bool = Boolean.valueOf(false)

    let boxed_int: Integer = 10
    let boxed_long: Long = 10
    let boxed_double: Double = 10.0
    let boxed_float: Float = 10.0
    let boxed_bool: Boolean = false

    let any = Inf { }
    any.test()
    any.testTwo(any)
    let ret = any.ret()
    ret = none()

    let testBox = some(10)



    let a_ = <int>[]
    a_[boxed_int] = 1

    println("Hello World")
    let \let = "ok"

    let a: string = 'hello $a_ end'
    let b: string = 'hello$a end'
    let c: string = 'hello$a$b-end'
    let d: string = '$c '
    let e: string = '$d'
    let f: string = '$\let'
    let g: string = '\$let'

    a = if true {
        "Hello"
    } else {
        return false
    }


    let array_assign: [Integer] = [1, 2, 3]

    //box(10) == 10

    let asInt: int = array_assign[2] + 0 + array_assign[1]

    any != a
}

/*
enum Option<T> {
    Some(value: T)
    None

    fn some<T>(value: T) -> T? {
        Option.Some { value: value }
    }

    fn none<T>() -> T? {
        Option.None {}
    }


    fn fromJava<T>(value: java.util.Optional<T>) -> T? {
        if value.isPresent() {
            Option.Some { value: value.get() }
        } else {
            Option.None {}
        }
       Option.None {}
    }

    fn fromNullable<T>(value: T) -> T? {
        if value != NULL_VALUE {
            Option.Some { value: value }
        } else {
            Option.None {}
        }
    }


    fn orElse(self, other: T) -> T {
        if self is Option.Some some {
            some.value
        } else is Option.None {
            other
        }
    }

    fn orElseGet(self, function: fn() -> T) -> T {
        if self is Option.Some some {
            some.value
        } else is Option.None {
            function()
        }
    }

    fn map<W>(self, function: fn(T) -> W) -> Option<W> {
        if self is Option.Some some {
            Option.Some { value: function(some.value) }
        } else is Option.None {
            Option.None {}
        }
    }

    fn mapOrElse<W>(self, mapFunction: fn(T) -> W, defaultValue: W) -> W {
        if self is Option.Some some {
            mapFunction(some.value)
        } else is Option.None {
            defaultValue
        }
    }

    fn or(self, other: Option<T>) -> Option<T> {
        if self is Option.Some some {
            self
        } else is Option.None {
            other
        }
    }

    fn and(self, other: Option<T>) -> Option<T> {
        if self is Option.Some some {
            other
        } else is Option.None none {
            none
        }
    }

    //not implemented on enums
    impl Interface

    //not implemented
    where T: impl Equals, T: impl Clone {
        fn contains(self, value: T) -> bool {
            if self is Option.Some some {
                some.value == value
            } else is Option.None {
                false
            }
        }
    }

}
*/

struct Test<W> {
    inner: W

    impl TestInterface<W, String> {

    }
}

struct Inf<T> {

    fn test(self) {
        self
    }

    fn ret(self) -> Inf<T>? {
        Option.Some { value: self }
    }

    fn testTwo<W>(self, other: Inf<W>) {

    }

    fn st() -> int {
        10
    }

}

interface TestInterface<T, B> {

}

struct ObjectSome {
    \fn: string
}

fn completePath<W>(s: W) {

}

struct ObjectToBase {
    element: int
}

@Super = {
    type: type { ObjectToBase }
    invocation: expr { super(value.length()) }
}
/*
@Init = {
    type: type { ObjectToBase }
    args: {
        number: type { int }
        name: type { string }
        value: type { int }
    }
    invocation: expr { super(value) }
}
*/

struct BasedObject {
    value: string
}

fn getAsAny<T>(t: T) -> ? = t

struct Other<W> {}

@Super = {
    type: type { Other<int> }
    invocation: expr { super() }
}
struct Inner {
    a: int
    b: src.Main.Inner
    type: int

    fn function(self, _: int) {

    }

    fn staticMethodReference() {

    }

    impl Interface
}

struct SimpleSupplier {
    value: int
    impl Supplier<Integer> {
        fn get(self) -> Integer {
            return Integer.valueOf(self.value)
        }
    }
}

interface Interface {
    fn function(self) -> bool
}


fn box(i: int) -> Integer {
    Integer.valueOf(i)
}

fn box(i: long) -> Long {
    Long.valueOf(i)
}

fn box(i: double) -> Double {
    Double.valueOf(i)
}

fn box(i: float) -> Float {
    Float.valueOf(i)
}

fn box(i: bool) -> Boolean {
    Boolean.valueOf(i)
}




/*
Expr
Value
Type
Struct
Interface
Enum
string
Block
tokenStream
Any

macro println(m: Value<bool>, function: code) -> Expr {

    code! {
        if m {
            \code()
        }
    }

}

macro code(stream: TOKEN_STREAM) {
    import karina.lang.TokenStream
    let lexer = grammar! {
        STRUCT: 'struct' id '{' field* '}';
    }
    let node = grammar.STRUCT(stream)

    let fields: [FIELD] = []
    let functions: [FUNCTION] = []
    let interfaces: [INTERFACE_IMPL_BLOCK] = []
    return DEFINE_STRUCT("Hello", fields, functions, interfaces)



}

*/