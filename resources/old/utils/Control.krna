import Writer Main


struct Array<A> {
    current: A
    next: Option<Array<A>>
}

fn main<T>(input: Array<string>) {
    let a: int = 1000
    let b = a + 100
    let array = [1, 2, 3][1]
    let www: int = a
    if true {
        
    } else if false {
        
    } else match obj {
        WW(a: WW) -> {
            return a
        }
        S() -> {
            return fn() -> bool {
                false
            }
        }
        Pair id -> {
            return id
        }
        _ -> {

        }
    }

    while 100 > babel.cc[d](1000) as bool {
        for i in list {
            break
        }
        continue
    }
    let func: fn(bool, string, Array<Option<T>>) -> int = fn(a,b,c) {

    }
   // let func2: fn(bool, string, Array<Option<T>>) -> int = fn(a: string, b, c) -> Array<Option<T>> {
    //    a.some[1000] = true && false
    //}

    let variable: Pair<int, string> = Pair<int, string> {
        first: 1000,
        second: "hello".substring(0, 1)
    }
    let array2: Array<WW> = <S<Reader<WW>>> [1, 2, 3]
    let list: [WW] = [1, 2, 3]

    let isWW = w as WW
    if isWW {
    }

    let some = if b {
        return
    } else if w is WW {
        return !s
        -some
    }

    if w as WW {

    }

    let asInstance: bool = w is WW
    let InstanceOf: WW = w.b as WW

    if w is WW ww {

    }

    if w is WW(w: T) {

    }
        
    ww.call()
    ww[1]

    while true {

    }
    let str: string = "hello"
    let obj = WW {
        a: 1,
        b: 2
    }
    

    self.here   

}


interface WW {
    impl Writer<int>
}

interface S<T> {
    fn a() -> T
    impl Other<int, T>
    impl Reader<byte>
    impl Writer<byte>
}

enum Other<A, B> {
    Some(value: A)
    Other(value: B)
}

interface Reader<T> {

}


@Annotation = {
    "a": 1,
    "b": 2
}
enum Option<T> {
    Some(value: T)
    None
}


@Annotation
struct Pair<T, U> {
    first: T
    second: U
}

