


fn test() -> bool {

    assert(true, "Boolean true is true")
    assertFalse(false)

    assertFalse(10 < 5)
    assertTrue(10 > 5)

    let wrapped = some(10)
    let unwrapped = unwrap(wrapped)
    assert(unwrapped == 10, "Unwrapped value should be 10")
    assertFalse(wrapped is None)
    assertTrue(wrapped is Some<?>)

    true
}

fn assertFalse(condition: bool) {
    if condition {
        raise Error { message: "Assertion failed" }
    }
}

fn assertTrue(condition: bool) {
    if !condition {
        raise Error { message: "Assertion failed" }
    }
}


fn assert(condition: bool, message: string) {
    if !condition {
        raise Error { message: message }
    }
}


@Throwable
struct Error {
    message: string
}


enum Option<T> {
    Some(value: T)
    None
}

fn some<T>(v: T) -> Option<T> = Some { value: v }
fn none<T>() -> Option<T> = None {}

fn unwrap<T>(option: Option<T>) -> T {
    if option is None {
        raise Error { message: "Option is None" }
    } else if option is Some<?> s {
        return s.value
    }
}

enum Result<T, E> {
    Ok(v: T)
    Err(e: E)
}

fn ok<T, E>(v: T) -> Result<T, E> = Ok { v: v }
fn err<T, E>(e: E) -> Result<T, E> = Err { e: e }

