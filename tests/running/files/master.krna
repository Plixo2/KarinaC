

pub fn main(args: [string]) {
   test()
}


fn test() -> bool {

    assert(true, "Boolean true is true")
    assertFalse(false)

    assertFalse(10 < 5)
    assertTrue(10 > 5)

    testMultiDimensionalArray()

    testEnum()
    assertTrue(testReturns())
    testInference()
    testStaticCall()
    testInterfaceCall()
    testVirtualCall()
    testDynamicCall()

    testCall()
}

fn testMultiDimensionalArray() {
    let a = [[1, 2, 3], [4, 5, 6]]
    let b: [[string]] = [["string", "none"]]
    b[0][0] = "test"
    b[0][1] = "test2"
}

fn testCall() -> bool  = true

fn testEnum() {
    let wrapped = Option::some(10)
    let unwrapped = unwrap(wrapped)
    assert(unwrapped == 10, "Unwrapped value should be 10")
    assertFalse(wrapped is None)
    assertTrue(wrapped is Some<any>)

}

fn testInference() {
    let anyT = ToInfer()
    let toInferArg = ToInferArg(Option::some(10))
    assertTrue(toInferArg is Ok<any, any>)
    let toInferArg2 = ToInferArg(Option.none())
    assertTrue(toInferArg2 is Err)


    let any2 = ToInfer()
    let toInferArg3 = ToInferArg(any2)
    assertTrue(toInferArg3 is Err)
    let setTypeOf3: Result<Integer, Integer> = toInferArg3

    let any3 = ToInfer()
    let toInferArg4 = ToInferArg(any3)
    assertTrue(toInferArg4 is Err<any, any>)
    let setTypeOf4: Result<string, Integer> = toInferArg4


    let anyAssigned: Option<Integer> = anyT

    let any4 = ToInfer()
    let anyAssigned2: Option<Option<string>> = any4
}

fn ToInfer<T>() -> Option<T> = Option::none()
fn ToInferArg<T>(option: Option<T>) -> Result<T, Integer> {
    if option is Some s {
        Result.ok(s.value())
    } else {
        Result.err(10)
    }
}

fn testReturns() -> bool {
    assertTrue(return2() == 0)
    assertTrue(return3(1) == 1)
    assertTrue(return3(0) == 0)

    assertTrue(return4(1) == 1)
    assertTrue(return4(0) == 0)


    assertTrue(return5(1) == 1)
    assertTrue(return5(0) == 0)

    returnTestA() == 1
}

fn returnTestA() -> int {
    return 1
}
fn return2() -> int = 0
fn return3(arg: int) -> int {
    if arg > 0 {
        return 1
    } else {
        return 0
    }
}
fn return4(arg: int) -> int {
    if arg > 0 {
        1
    } else {
        0
    }
}
fn return5(arg: int) -> int =
    return if arg > 0 {
        1
    } else {
        0
    }



fn testStaticCall() {
    assertTrue(staticGeneric(10) == 10)
    assertTrue(staticGeneric(true) == true)
    assertTrue(staticGeneric(0.04) == 0.04)
    assertTrue(staticGenericUnknown(10) == 10)
    let v1 = staticGenericNested(Option.none(), 10)
    assertTrue(v1 is Err)
    let v2 = staticGenericNested(Option.some(true), 10)
    assertTrue(v2 is Ok<any,any>)

    assertTrue(orDefault(Option.some(10), 20) == 10)
    assertTrue(orDefault(Option.none(), 20) == 20)
}
fn staticGeneric<T>(value: T) -> T = value
fn staticGenericUnknown<T>(value: int) -> int = value
fn staticGenericNested<T, E>(value: Option<T>, err: E) -> Result<T, E> {
    if value is Some<any> s {
        return Result.ok(s.value())
    } else {
        return Result.err(err)
    }
}

fn orDefault<T>(value: Option<T>, defaultValue: T) -> T {
    if value is Some<any> s {
        return s.value()
    } else {
        return defaultValue
    }
}

fn testVirtualCall() {
    let obj: DefaultStruct = DefaultStruct.default()
    assertTrue(obj.getValue() == 10)
    obj.setValue(20)
    assertTrue(obj.getValue() == 20)
    assertTrue(obj.value == 20)
}

fn testDynamicCall() {
    let f = fn(a) -> int impl java::util::function::IntUnaryOperator {
        a
    }
    let w: fn(int) -> int = f
    f(0)

    let f2 = fn(a) impl BooleanUnary a
    f2(true)
    let w2 : fn(bool) -> bool impl BooleanUnary = f2

    let f3 = fn(a: Integer) Option.some(a)
    assertTrue(f3(10) is Some<any>)
    let w3: fn(Integer) -> Option<Integer> = f3
}

interface BooleanUnary {
    pub fn call(self, a: bool) -> bool
}

fn testInterfaceCall() {
    let dut = InterfaceImpl { value: 10 }

    assertTrue(dut.value == 10)
    assertTrue(dut.call() == 10)
    dut.callVoid()
    assertTrue(dut.callArgs(1, 2))

    callAsInterface(dut)
    assertTrue(InterfaceTest.staticCall() == 10)
    assertTrue(InterfaceImpl.staticCall() == 20)
}

fn callAsInterface(dut: InterfaceTest<Integer>) {
    dut.set(20)
    assertTrue(dut.call() == 20)
    dut.callVoid()
    assertTrue(dut.callArgs(1, 2))
}

struct InterfaceImpl {
    mut value: int

    fn staticCall() -> int = 20

    impl InterfaceTest<Integer> {
        fn call(self) -> int = self.value
        fn callVoid(self) {
            //?
        }
        fn callArgs(self, a: int, b: Integer) -> bool {
            assertTrue(a == 1)
            assertTrue(b == 2)
            true
        }
        fn set(self, value: Integer) {
            self.value = value
        }
    }
}

interface InterfaceTest<T> {
    pub fn call(self) -> int
    pub fn callVoid(self)
    pub fn callArgs(self, a: int, b: T) -> bool
    pub fn set(self, value: T)

    fn staticCall() -> int = 10
}

struct DefaultStruct {
    mut value: int

    fn setValue(self, value: int) {
        self.value = value
    }
    fn default() -> DefaultStruct {
        DefaultStruct { value: 10 }
    }
    fn getValue(self) -> int {
        self.value
    }

}




fn unwrap<T>(option: Option<T>) -> T {
    if option is None n {
        throw Error { message: "Option is None" }
    } else is Some<any> s {
        s.value()
    }
}



fn assertFalse(condition: bool) {
    if condition {
        throw AssertionError { _: "Assertion failed" }
    }
}

fn assertTrue(condition: bool) {
    if !condition {
        throw AssertionError { _: "Assertion failed" }
    }
}


fn assert(condition: bool, message: string) {
    if !condition {
        throw AssertionError { _: message }
    }
}